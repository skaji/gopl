# 9章

8章でgolangではゴルーチンを使って簡単に並行プログラムを書けることを学んだ。9章では

* 並行プログラムで問題となること
* 問題を識別するための分析方法
* 解決するためのパターン

を学ぶ。

# 9.1 競合状態

競合状態とは、複数の処理が同時に走ることにより結果が不定になる状態のこと。

とくに、複数の処理が同じ変数にアクセスし、
しかもそのアクセスのうち少なくとも１つが書き込み処理のとき、競合状態がよく起こる。
これをデータ競合と呼ぶ。

## データ競合の例

* [0901-1-intro](0901-1-intro)
* [0901-2-intro](0901-2-intro)

## 覚えておきたい言葉

> 自分のプログラムにおける既知のデータ競合を時々次のように正当化します。
>
>     「相互排他のコストが高すぎる」
>     「このロジックはログ処理のためだけにある」
>     「いくつかのメッセージを失っても構わない」
>
> （中略) 無害なデータ競合などというものは存在しないということです。

## データ競合を避ける3つの方法

* (1) 変数への書き込みをやめる
* (2) 複数のゴルーチンからの変数へのアクセスを避ける
* (3) 複数のゴルーチンに変数へのアクセスを許可するが、一度にひとつのゴルーチンだけにアクセスさせる

(1)とできるなら1がよい。
(1)がだめなとき(2)を考える、(2)もだめなとき(3)を考える、とするとよろしい。

### (1) 変数への書き込みをやめる

例えば、書き込みはプログラムのはじめに一度だけ行い、
その後はどのゴルーチンからも読み込みのみの処理にできるかもしれない。

[0901-3-do-no-write](0901-3-do-no-write)

### (2) 複数のゴルーチンからの変数へのアクセスを避ける

* ある変数Vへのアクセスを、ある１つのゴルーチンGだけに閉じ込める。他のゴルーチンが変数Vにアクセスしたいときはチャンネルを通じてゴルーチンGとアクセスし変数の参照、更新をゴルーチンGに依頼する。このときゴルーチンGをモニターゴルーチンと呼ぶ。
    * [0901-4-monitor-groutine](0901-4-monitor-groutine)
* ある変数Vの生存期間全体を、ある１つのゴルーチンだけに閉じ込めることは無理でも、順次、あるゴルーチンに閉じ込めることはできるかもしれない。
    * [0901-5-serial-confinement](0901-5-serial-confinement)

### (3) 複数のゴルーチンに変数へのアクセスを許可するが、一度にひとつのゴルーチンだけにアクセスさせる

9.2で扱う。

# 9.2 排他制御

以前やったチャンネルを使う方法とsync.Mutexを使う方法がある。
排他制御用途としては専用に準備されているsync.Mutexを使うのがよい。

なお排他制御が必要になる部分(= 複数の処理が同時に走ると破綻をきたす部分)をクリティカルセクションと呼ぶ。

## チャンネルを使う方法

[0902-1-chan](0902-1-chan)

## sync.Mutexを使う方法

* [0902-2-mutex](0902-2-mutex)
* [0902-3-mutex-note](0902-3-mutex-note)

# 9.3 リード、ライトミューテックス

ほとんどのゴルーチンが読み込みのみのとき、sync.Mutexよりもsync.RWMutexを使ったほうがいいかもしれない。

[0903-rwlock](0903-rwlock)

# 9.4 メモリ同期

下記のプログラムの出力がどうなる可能性があるか考えてみる。

```go
var x, y int
go func() { // A
  x = 1
  fmt.Print("y:", y, " ")
}()
go func() { // B
  y = 1
  fmt.Print("x:", x, " ")
}()
```

驚くべきことに
```
x:0 y:0
y:0 x:0
```
などとなることがある。なぜか。

# 9.5 遅延初期化

コストの高い初期化を必要になるまで遅延させたいときはよくある。
その方法としてsync.Mutexを使う方法もあるが専用のsync.Onceを使うとよい。

[0905-defer-init](0905-defer-init)

# 9.6 競合検出器

`go build`, `go run`, `go test`には`-race`オプションをつけると競合を検出できる。
実際の例は9.7で扱う。

# 9.7 例: 並行的で待たされないキャッシュ

ある関数の結果をキャッシュする機構(= メモ化)を実装してみる。使い方は以下のような感じ。

```go
// 任意の返り値を扱えるようにinterface{}を返す関数として扱う
type Func func(key string) (interface{}, error)

m := memo.New(someHeavyFunc)

v, err := m.Get("key1")
v, err := m.Get("key2")

v, err := m.Get("key1") // すでにkey1を一度呼んでいるので、キャッシュの結果を使いすぐにreturnされる
```

ここで作るキャッシュの目標は

* (A) 並行に扱っても安全であること
* (B) 無駄な処理がないこと
* (C) 必要以上に待たされないこと

である。

## 案1: 素朴な実装

[0907-memo/1/memo.go](0907-memo/1/memo.go)

並行に呼ばれたらまずい。(A)が満たされていない。`go test -race`を使うとわかる。

## 案2: 並行に呼ばれてもいいようにmutexを使う

[0907-memo/2/memo.go](0907-memo/2/memo.go)

全部を一度止めてしまっている。(C)が満たされていない。

## 案2': 並行に呼ばれてもいいようにモニターゴルーチンを使う

[0907-memo/2_1/memo.go](0907-memo/2_1/memo.go)

モニターゴルーチン内で直列に処理してしまっている。(C)が満たされていない。

## 案3: 案2の改良版、mutex.Lockを２度使い、なるべく待たされないようにする

[0907-memo/3/memo.go](0907-memo/3/memo.go)

同じkeyに対し、複数回関数が呼ばれる可能性がある。(B)が満たされていない。


## 案4: 案3の改良版、ブロードキャストを使い重複抑制をする

[0907-memo/4/memo.go](0907-memo/4/memo.go)

いい。(A),(B),(C)すべて満たせている。

## 案5: 案2'の改良版

[0907-memo/5/memo.go](0907-memo/5/memo.go)

いい。(A),(B),(C)すべて満たせている。

練習問題9.3 [../0903](../0903)

# 9.8 ゴルーチンとスレッド

ゴルーチンとスレッドの違いを述べていく・。

## 9.8.1 スタック

スタックとは実行中の関数呼び出し、もしくは他の関数が呼ばれている間は一時停止している関数呼び出しでのローカル変数が保存されている場所である。

* スレッド: 固定長のスタックを持つ。たいてい2MB
* ゴルーチン: 伸長可能なスタックを持つ。たいてい2KB、最大1GB

例: [0908-stack/stack.go](0908-stack/stack.go)

練習問題9.4 [../0904](../0904)

## 9.8.2 スケジュール

* スレッド: ハードウェアタイマーがプロセッサに割り込み、カーネル関数スケジューラによりスケジュールされる。
スレッドを切り替えるときは、いまのスレッドの状態をメモリに保存し、別のスレッドの状態を回復する(= コンテキストスイッチ)が必要となる。
* ゴルーチン: goはm個のゴルーチンをnこのスレッドによって多重化している。goはm:nスケジューラと呼ばれる技法を使った独自スケジューラをもつ。goの構造によって暗黙的にgoのスケジューラが起動される。

練習問題9.5 [../0905](../0905)

## 9.8.3 GOMAXPROCS

GOMAXPROCSでgoが使うOSスレッドの数を取得、設定できる。デフォルトはCPUの数。

環境変数から設定。
```
env GOMAXPROCS=100 go run main.go
```

プログラム上で取得、設定。
```go
fmt.Println(runtime.GOMAXPROCS(0))
runtime.GOMAXPROCS(100)
```

GOMAXPROCSを変えることで、あるゴルーチンでは1, あるゴルーチンでは0を表示するプログラムがどうなるか確認してみる。
[0908-gomaxprocs/main.go](0908-gomaxprocs/main.go)

練習問題 9.6 [../0906](../0906)

## 9.8.4 ゴルーチンは識別子を持たない

たいていスレッドはプログラムで容易に扱える識別子をもっている。
よってその識別子によってグローバル上にスレッドローカル領域を作ることができる。

一方goはあえてゴルーチンにプログラムから要因に取得できる識別子を持たせていない。
それはスレッドローカル領域の乱用を防ぐためである。
