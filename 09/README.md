# 9章

8章でgolangではゴルーチンを使って簡単に並行プログラムを書けることを学んだ。9章では

* 並行プログラムで問題となること
* 問題を識別するための分析方法
* 解決するためのパターン

を学ぶ。

# 9.1 競合状態

競合状態とは、複数の処理が同時に走ることにより結果が不定になる状態のこと。

とくに、複数の処理が同じ変数にアクセスし、
しかもそのアクセスのうち少なくとも１つが書き込み処理のとき、競合状態がよく起こる。
これをデータ競合と呼ぶ。

## データ競合の例

* [0901-1-intro](0901-1-intro)
* [0901-2-intro](0901-2-intro)

## 覚えておきたい言葉

> 自分のプログラムにおける既知のデータ競合を時々次のように正当化します。
>
>     「相互排他のコストが高すぎる」
>     「このロジックはログ処理のためだけにある」
>     「いくつかのメッセージを失っても構わない」
>
> （中略) 無害なデータ競合などというものは存在しないということです。

## データ競合を避ける3つの方法

* (1) 変数への書き込みをやめる
* (2) 複数のゴルーチンからの変数へのアクセスを避ける
* (3) 複数のゴルーチンに変数へのアクセスを許可するが、一度にひとつのゴルーチンだけにアクセスさせる

(1)とできるなら1がよい。
(1)がだめなとき(2)を考える、(2)もだめなとき(3)を考える、とするとよろしい。

### (1) 変数への書き込みをやめる

例えば、書き込みはプログラムのはじめに一度だけ行い、
その後はどのゴルーチンからも読み込みのみの処理にできるかもしれない。

[0901-3-do-no-write](0901-3-do-no-write)

### (2) 複数のゴルーチンからの変数へのアクセスを避ける

* ある変数Vへのアクセスを、ある１つのゴルーチンGだけに閉じ込める。他のゴルーチンが変数Vにアクセスしたいときはチャンネルを通じてゴルーチンGとアクセスし変数の参照、更新をゴルーチンGに依頼する。このときゴルーチンGをモニターゴルーチンと呼ぶ。
    * [0901-4-monitor-groutine](0901-4-monitor-groutine)
* ある変数Vの生存期間全体を、ある１つのゴルーチンだけに閉じ込めることは無理でも、順次、あるゴルーチンに閉じ込めることはできるかもしれない。
    * [0901-5-serial-confinement](0901-5-serial-confinement)

### (3) 複数のゴルーチンに変数へのアクセスを許可するが、一度にひとつのゴルーチンだけにアクセスさせる

9.2で扱う。

# 9.2 排他制御

以前やったチャンネルを使う方法とsync.Mutexを使う方法がある。
排他制御用途としては専用に準備されているsync.Mutexを使うのがよい。

なお排他制御が必要になる部分(= 複数の処理が同時に走ると破綻をきたす部分)をクリティカルセクションと呼ぶ。

## チャンネルを使う方法

[0902-1-chan](0902-1-chan)

## sync.Mutexを使う方法

* [0902-2-mutex](0902-2-mutex)
* [0902-3-mutex-note](0902-3-mutex-note)

# 9.3 リード、ライトミューテックス

ほとんどのゴルーチンが読み込みのみのとき、sync.Mutexよりもsync.RWMutexを使ったほうがいいかもしれない。

[0903-rwlock](0903-rwlock)

# 9.4 メモリ同期

下記のプログラムの出力がどうなる可能性があるか考えてみる。

```go
var x, y int
go func() { // A
  x = 1
  fmt.Print("y:", y, " ")
}()
go func() { // B
  y = 1
  fmt.Print("x:", x, " ")
}()
```

驚くべきことに
```
x:0 y:0
y:0 x:0
```
などとなることがある。なぜか。

# 9.5 遅延初期化

コストの高い初期化を必要になるまで遅延させたいときはよくある。
その方法としてsync.Mutexを使う方法もあるが専用のsync.Onceを使うとよい。

[0905-defer-init](0905-defer-init)

# 9.6 競合検出器

`go build`, `go run`, `go test`には`-race`オプションをつけると競合を検出できる。
実際の例は9.7で扱う。

# 9.7 例: 並行的で待たされないキャッシュ

ある関数の結果をキャッシュする機構(= メモ化)を実装してみる。使い方は以下のような感じ。

```go
// 任意の返り値を扱えるようにinterface{}を返す関数として扱う
type Func func(key string) (interface{}, error)

m := memo.New(someHeavyFunc)

v, err := m.Get("key1")
v, err := m.Get("key2")

v, err := m.Get("key1") // すでにkey1を一度呼んでいるので、キャッシュの結果を使いすぐにreturnされる
```

ここで作るキャッシュの目標は

* (A) 並行に扱っても安全であること
* (B) 無駄な処理がないこと
* (C) 必要以上に待たされないこと

である。

## 案1: 素朴な実装

[0907-memo/1/memo.go]()

並行に呼ばれたらまずい。(A)が満たされていない。`go test -race`を使うとわかる。

## 案2: 並行に呼ばれてもいいようにmutexを使う

[0907-memo/2/memo.go]()

全部を一度止めてしまっている。(C)が満たされていない。

## 案2': 並行に呼ばれてもいいようにモニターゴルーチンを使う

[0907-memo/2_1/memo.go]()

モニターゴルーチン内で直列に処理してしまっている。(C)が満たされていない。

## 案3: 案2の改良版、mutex.Lockを２度使い、なるべく待たされないようにする

[0907-memo/3/memo.go]()

同じkeyに対し、複数回関数が呼ばれる可能性がある。(B)が満たされていない。


## 案4: 案3の改良版、ブロードキャストを使い重複抑制をする

[0907-memo/4/memo.go]()

いい。(A),(B),(C)すべて満たせている。

## 案5: 案2'の改良版

[0907-memo/5/memo.go]()

いい。(A),(B),(C)すべて満たせている。

# 練習問題

* 9.1 [../0901](../0901)
* 9.2 [../0902](../0902)

