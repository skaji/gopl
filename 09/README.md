# 9章

8章でgolangではゴルーチンを使って簡単に並行プログラムを書けることを学んだ。9章では

* 並行プログラムで問題となること
* 問題を識別するための分析方法
* 解決するためのパターン

を学ぶ。

# 9.1 競合状態

競合状態とは、複数の処理が同時に走ることにより結果が不定になる状態のこと。

とくに、複数の処理が同じ変数にアクセスし、
しかもそのアクセスのうち少なくとも１つが書き込み処理のとき、競合状態がよく起こる。
これをデータ競合と呼ぶ。

## データ競合の例

* [0901-1-intro](0901-1-intro)
* [0901-2-intro](0901-2-intro)

## 覚えておきたい言葉

> 自分のプログラムにおける既知のデータ競合を時々次のように正当化します。
>
>     「相互排他のコストが高すぎる」
>     「このロジックはログ処理のためだけにある」
>     「いくつかのメッセージを失っても構わない」
>
> （中略) 無害なデータ競合などというものは存在しないということです。

## データ競合を避ける3つの方法

* (1) 変数への書き込みをやめる
* (2) 複数のゴルーチンからの変数へのアクセスを避ける
* (3) 複数のゴルーチンに変数へのアクセスを許可するが、一度にひとつのゴルーチンだけにアクセスさせる

(1)とできるなら1がよい。
(1)がだめなとき(2)を考える、(2)もだめなとき(3)を考える、とするとよろしい。

### (1) 変数への書き込みをやめる

例えば、書き込みはプログラムのはじめに一度だけ行い、
その後はどのゴルーチンからも読み込みのみの処理にできるかもしれない。

[0901-3-do-no-write](0901-3-do-no-write)

### (2) 複数のゴルーチンからの変数へのアクセスを避ける

* ある変数Vへのアクセスを、ある１つのゴルーチンGだけに閉じ込める。他のゴルーチンが変数Vにアクセスしたいときはチャンネルを通じてゴルーチンGとアクセスし変数の参照、更新をゴルーチンGに依頼する。このときゴルーチンGをモニターゴルーチンと呼ぶ。
    * [0901-4-monitor-groutine](0901-4-monitor-groutine)
* ある変数Vの生存期間全体を、ある１つのゴルーチンだけに閉じ込めることは無理でも、順次、あるゴルーチンに閉じ込めることはできるかもしれない。
    * [0901-5-serial-confinement](0901-5-serial-confinement)

### (3) 複数のゴルーチンに変数へのアクセスを許可するが、一度にひとつのゴルーチンだけにアクセスさせる

9.2で扱う。

# 9.2 排他制御

以前やったチャンネルを使う方法とsync.Mutexを使う方法がある。
排他制御用途としては専用に準備されているsync.Mutexを使うのがよい。

なお排他制御が必要になる部分(= 複数の処理が同時に走ると破綻をきたす部分)をクリティカルセクションと呼ぶ。

## チャンネルを使う方法

[0902-1-chan](0902-1-chan)

## sync.Mutexを使う方法

* [0902-2-mutex](0902-2-mutex)
* [0902-3-mutex-note](0902-3-mutex-note)

# 9.3 リード、ライトミューテックス

ほとんどのゴルーチンが読み込みのみのとき、sync.Mutexよりもsync.RWMutexを使ったほうがいいかもしれない。

[0903-rwlock](0903-rwlock)

# 9.4 メモリ同期

下記のプログラムの出力がどうなる可能性があるか考えてみる。

```go
var x, y int
go func() { // A
  x = 1
  fmt.Print("y:", y, " ")
}()
go func() { // B
  y = 1
  fmt.Print("x:", x, " ")
}()
```

驚くべきことに
```
x:0 y:0
y:0 x:0
```
などとなることがある。なぜか。

# 9.5 遅延初期化

コストの高い初期化を必要になるまで遅延させたいときはよくある。
その方法としてsync.Mutexを使う方法もあるが専用のsync.Onceを使うとよい。

[0905-defer-init](0905-defer-init)
